class e{constructor(){this.config={cacheMode:"local",instantHover:!0,maxConcurrent:3,selector:"a[href]",initialDelay:1e3,betweenDelay:100,hoverDelay:150,excludeSelectors:["[download]",'[target="_blank"]','[href^="mailto:"]','[href^="tel:"]','[href^="#"]',".no-preload"],excludePatterns:[/\.(pdf|zip|doc|docx|xls|xlsx|ppt|pptx)$/i,/\.(jpg|jpeg|png|gif|svg|webp)$/i,/^javascript:/,/^data:/],fetchHeaders:{},requestTimeout:1e4,connectionAware:!0,dataLimit:52428800,bandwidthThrottle:!0,cacheMaxSize:100,cacheExpiration:864e5,cacheVersion:"1.0",crossTabCache:!0,debug:!1,verboseLogging:!1,instantTransitions:!0,ssrHints:!0},this.queue=[],this.processing=new Set,this.processed=new Set,this.cache=new Map,this.cacheAPI=null,this.isInitialized=!1,this.activeRequests=0,this.hoverTimeouts=new Map,this.dataUsed=0,this.sessionStart=Date.now(),this.connectionInfo=null,this.bandwidthEstimate=null,this.ssrHintsReceived=new Set,this.stats={totalRequests:0,cacheHits:0,cacheMisses:0,bytesTransferred:0,averageResponseTime:0,connectionType:"unknown"},this.broadcastChannel=null}static init(t={}){const s=new e;return s.configure(t),s.start(),s}configure(e){this.config={...this.config,...e},this.log("Configured with options:",this.config)}async start(){this.isInitialized?this.debugLog("Already initialized"):(this.debugLog("Starting Ghostloader..."),this.config.connectionAware&&await this.detectConnection(),this.config.crossTabCache&&this.setupCrossTabCache(),await this.initializeCache(),this.config.ssrHints&&this.processSSRHints(),this.config.initialDelay>0&&(this.debugLog(`Waiting ${this.config.initialDelay}ms before starting preloading`),await this.delay(this.config.initialDelay)),this.buildQueue(),this.config.instantHover&&this.setupHoverListeners(),this.config.instantTransitions&&this.setupInstantTransitions(),this.processQueue(),this.isInitialized=!0,this.debugLog("Ghostloader initialized successfully"))}async initializeCache(){try{"caches"in window?(this.cacheAPI=await caches.open("ghostloader-cache-v1"),this.log("Cache API initialized")):this.log("Cache API not available, using memory fallback")}catch(e){this.log("Cache API initialization failed, using memory fallback:",e)}}buildQueue(){const e=document.querySelectorAll(this.config.selector),t=[];e.forEach(e=>{const s=this.normalizeUrl(e.href);if(!s||this.processed.has(s)||this.processing.has(s))return;if(this.shouldExclude(e,s))return void this.verboseLog("Excluded link:",s);if(!this.shouldPreload(s))return;if(this.config.connectionAware&&!this.withinDataLimits())return void this.debugLog("Data limit reached, skipping preloading");const i=e.getBoundingClientRect();i.top<window.innerHeight&&i.bottom>0&&t.push({url:s,element:e,priority:i.top,timestamp:Date.now()})}),t.sort((e,t)=>e.priority-t.priority),this.queue=t,this.debugLog(`Built queue with ${this.queue.length} links`)}shouldPreload(e){try{const t=new URL(e),s=window.location.origin;return"local"!==this.config.cacheMode||t.origin===s}catch(t){return this.log("Invalid URL:",e,t),!1}}normalizeUrl(e){try{const t=new URL(e,window.location.href);return t.hash="",t.href}catch(e){return null}}setupHoverListeners(){document.addEventListener("mouseenter",e=>{if(e.target.matches(this.config.selector)){const t=this.normalizeUrl(e.target.href);if(t&&this.shouldPreload(t)&&!this.shouldExclude(e.target,t)){this.hoverTimeouts.has(e.target)&&clearTimeout(this.hoverTimeouts.get(e.target));const s=setTimeout(()=>{this.boostPriority(t),this.hoverTimeouts.delete(e.target)},this.config.hoverDelay);this.hoverTimeouts.set(e.target,s)}}},!0),document.addEventListener("mouseleave",e=>{e.target.matches(this.config.selector)&&this.hoverTimeouts.has(e.target)&&(clearTimeout(this.hoverTimeouts.get(e.target)),this.hoverTimeouts.delete(e.target))},!0),this.debugLog("Hover listeners enabled with",this.config.hoverDelay,"ms delay")}boostPriority(e){const t=this.queue.findIndex(t=>t.url===e);if(t>0){const s=this.queue.splice(t,1)[0];this.queue.unshift(s),this.log("Boosted priority for:",e),this.processQueue()}}async processQueue(){for(;this.queue.length>0&&this.activeRequests<this.getEffectiveMaxConcurrent();){const e=this.queue.shift();if(e&&!this.processing.has(e.url)&&!this.processed.has(e.url)){if(this.config.connectionAware&&!this.withinDataLimits()){this.debugLog("Data limit reached, pausing queue processing");break}this.processing.add(e.url),this.activeRequests++,this.config.betweenDelay>0&&this.activeRequests>1&&await this.delay(this.config.betweenDelay),this.fetchAndCache(e).finally(()=>{this.processing.delete(e.url),this.processed.add(e.url),this.activeRequests--,this.queue.length>0&&setTimeout(()=>this.processQueue(),10)})}}}async fetchAndCache(e){const{url:t}=e,s=Date.now();try{this.verboseLog("Fetching:",t),this.stats.totalRequests++;const e=await this.getCachedResponse(t);if(e&&!this.isCacheExpired(e))return this.debugLog("Cache hit:",t),void this.stats.cacheHits++;const i={method:"GET",mode:"external"===this.config.cacheMode?"cors":"same-origin",credentials:"same-origin",cache:"default",headers:{...this.config.fetchHeaders,"X-Ghostloader":"preload","X-Ghostloader-Version":this.config.cacheVersion}},a=new AbortController,n=setTimeout(()=>a.abort(),this.config.requestTimeout);i.signal=a.signal;const o=await fetch(t,i);if(clearTimeout(n),o.ok){const e=o.headers.get("content-length");e&&(this.dataUsed+=parseInt(e,10)),await this.storeInCache(t,o.clone(),{timestamp:Date.now(),version:this.config.cacheVersion,size:e?parseInt(e,10):0}),this.debugLog("Cached:",t),this.stats.cacheMisses++,this.stats.bytesTransferred+=e?parseInt(e,10):0,this.broadcastCacheUpdate(t,"cached")}else this.debugLog("Fetch failed:",t,o.status);const c=Date.now()-s;this.stats.averageResponseTime=(this.stats.averageResponseTime*(this.stats.totalRequests-1)+c)/this.stats.totalRequests}catch(e){"AbortError"===e.name?this.debugLog("Request timeout:",t):this.debugLog("Fetch error:",t,e.message)}}async isInCache(e){try{if(this.cacheAPI){return!!await this.cacheAPI.match(e)}return this.cache.has(e)}catch(e){return this.log("Cache check error:",e),!1}}async storeInCache(e,t){try{this.cacheAPI?await this.cacheAPI.put(e,t):this.cache.set(e,{url:e,timestamp:Date.now(),status:t.status})}catch(e){this.log("Cache store error:",e)}}shouldExclude(e,t){for(const t of this.config.excludeSelectors)if(e.matches(t))return!0;for(const e of this.config.excludePatterns)if(e.test(t))return!0;return!1}async detectConnection(){try{"connection"in navigator&&(this.connectionInfo=navigator.connection,this.stats.connectionType=this.connectionInfo.effectiveType||"unknown",this.connectionInfo.downlink&&(this.bandwidthEstimate=1e3*this.connectionInfo.downlink*1e3),this.debugLog("Connection detected:",{type:this.connectionInfo.effectiveType,downlink:this.connectionInfo.downlink,saveData:this.connectionInfo.saveData}),this.connectionInfo.addEventListener("change",()=>{this.debugLog("Connection changed:",this.connectionInfo.effectiveType),this.stats.connectionType=this.connectionInfo.effectiveType}))}catch(e){this.debugLog("Connection detection failed:",e)}}withinDataLimits(){return this.connectionInfo&&this.connectionInfo.saveData?(this.debugLog("Data saver mode enabled, skipping preload"),!1):!(this.dataUsed>=this.config.dataLimit)}getEffectiveMaxConcurrent(){if(!this.config.bandwidthThrottle||!this.connectionInfo)return this.config.maxConcurrent;return{"slow-2g":1,"2g":1,"3g":2,"4g":this.config.maxConcurrent,"5g":this.config.maxConcurrent}[this.connectionInfo.effectiveType]||this.config.maxConcurrent}setupCrossTabCache(){try{"BroadcastChannel"in window&&(this.broadcastChannel=new BroadcastChannel("ghostloader-cache"),this.broadcastChannel.addEventListener("message",e=>{const{type:t,url:s,data:i}=e.data;"cache-update"===t?(this.verboseLog("Received cache update from another tab:",s),this.processed.add(s)):"cache-invalidate"===t&&(this.verboseLog("Received cache invalidation from another tab:",s),this.invalidateCache(s))}),this.debugLog("Cross-tab cache communication enabled"))}catch(e){this.debugLog("Cross-tab cache setup failed:",e)}}broadcastCacheUpdate(e,t){this.broadcastChannel&&this.broadcastChannel.postMessage({type:"cache-update",url:e,action:t,timestamp:Date.now()})}processSSRHints(){try{document.querySelectorAll('meta[name="ghostloader-hint"]').forEach(e=>{const t=e.getAttribute("content"),s=e.getAttribute("data-priority")||"normal";t&&!this.ssrHintsReceived.has(t)&&(this.ssrHintsReceived.add(t),"high"===s&&this.queue.unshift({url:this.normalizeUrl(t),element:null,priority:-1e3,timestamp:Date.now(),source:"ssr-hint"}),this.verboseLog("Processed SSR hint:",t,"priority:",s))});document.querySelectorAll('script[type="application/ld+json"]').forEach(e=>{try{const t=JSON.parse(e.textContent);t.ghostloaderHints&&Array.isArray(t.ghostloaderHints)&&t.ghostloaderHints.forEach(e=>{e.url&&!this.ssrHintsReceived.has(e.url)&&(this.ssrHintsReceived.add(e.url),this.queue.unshift({url:this.normalizeUrl(e.url),element:null,priority:e.priority||0,timestamp:Date.now(),source:"ssr-hint-json"}))})}catch(e){}})}catch(e){this.debugLog("SSR hints processing failed:",e)}}setupInstantTransitions(){document.addEventListener("click",async e=>{if(e.target.matches(this.config.selector)&&!e.defaultPrevented){const t=this.normalizeUrl(e.target.href);if(t&&await this.isInCache(t)&&!this.shouldExclude(e.target,t)){const s=await this.getCachedResponse(t);if(s&&!this.isCacheExpired(s)){e.preventDefault();try{const e=await s.text(),i=(new DOMParser).parseFromString(e,"text/html");document.title=i.title,document.head.innerHTML=i.head.innerHTML,document.body.innerHTML=i.body.innerHTML,history.pushState(null,i.title,t),setTimeout(()=>{this.buildQueue(),this.processQueue()},100),this.debugLog("Instant transition to:",t)}catch(e){this.debugLog("Instant transition failed:",e),window.location.href=t}}}}}),this.debugLog("Instant transitions enabled")}async getCachedResponse(e){try{if(this.cacheAPI)return await this.cacheAPI.match(e);if(this.cache.has(e)){const t=this.cache.get(e);return{ok:!0,status:200,text:()=>Promise.resolve(t.content||""),clone:()=>this.getCachedResponse(e),headers:new Map([["x-cached-timestamp",t.timestamp.toString()]])}}}catch(e){this.debugLog("Cache retrieval error:",e)}return null}isCacheExpired(e){try{const t=e.headers.get("x-cached-timestamp")||e.headers.get("x-ghostloader-timestamp");if(t){return Date.now()-parseInt(t,10)>this.config.cacheExpiration}}catch(e){this.debugLog("Cache expiration check error:",e)}return!1}async storeInCache(e,t,s={}){try{if(await this.enforceCacheLimit(),this.cacheAPI){const i=new Response(t.body,{status:t.status,statusText:t.statusText,headers:{...Object.fromEntries(t.headers.entries()),"x-ghostloader-timestamp":s.timestamp||Date.now(),"x-ghostloader-version":s.version||this.config.cacheVersion,"x-ghostloader-size":s.size||0}});await this.cacheAPI.put(e,i)}else{const i=await t.text();this.cache.set(e,{url:e,content:i,timestamp:s.timestamp||Date.now(),version:s.version||this.config.cacheVersion,size:s.size||i.length})}}catch(e){this.debugLog("Cache store error:",e)}}async enforceCacheLimit(){try{if(this.cacheAPI){const e=await this.cacheAPI.keys();if(e.length>=this.config.cacheMaxSize){const t=e.slice(0,e.length-this.config.cacheMaxSize+10);await Promise.all(t.map(e=>this.cacheAPI.delete(e))),this.debugLog("Cleaned cache, removed",t.length,"entries")}}else if(this.cache.size>=this.config.cacheMaxSize){const e=Array.from(this.cache.entries()).sort((e,t)=>e[1].timestamp-t[1].timestamp),t=e.slice(0,e.length-this.config.cacheMaxSize+10);t.forEach(([e])=>this.cache.delete(e)),this.debugLog("Cleaned memory cache, removed",t.length,"entries")}}catch(e){this.debugLog("Cache cleanup error:",e)}}async invalidateCache(e){try{this.cacheAPI?await this.cacheAPI.delete(e):this.cache.delete(e),this.debugLog("Invalidated cache for:",e)}catch(e){this.debugLog("Cache invalidation error:",e)}}delay(e){return new Promise(t=>setTimeout(t,e))}debugLog(...e){this.config.debug&&"undefined"!=typeof console&&console.log("[Ghostloader Debug]",...e)}verboseLog(...e){this.config.verboseLogging&&"undefined"!=typeof console&&console.log("[Ghostloader Verbose]",...e)}log(...e){this.debugLog(...e)}getStats(){const e=this.cacheAPI?"Cache API":this.cache.size,t=Date.now()-this.sessionStart;return{queueLength:this.queue.length,processing:this.processing.size,processed:this.processed.size,activeRequests:this.activeRequests,cacheSize:e,cacheMaxSize:this.config.cacheMaxSize,cacheExpiration:this.config.cacheExpiration,cacheVersion:this.config.cacheVersion,totalRequests:this.stats.totalRequests,cacheHits:this.stats.cacheHits,cacheMisses:this.stats.cacheMisses,cacheHitRate:this.stats.totalRequests>0?(this.stats.cacheHits/this.stats.totalRequests*100).toFixed(2)+"%":"0%",connectionType:this.stats.connectionType,bandwidthEstimate:this.bandwidthEstimate,dataUsed:this.dataUsed,dataLimit:this.config.dataLimit,dataUsagePercent:(this.dataUsed/this.config.dataLimit*100).toFixed(2)+"%",sessionDuration:t,averageResponseTime:this.stats.averageResponseTime.toFixed(2)+"ms",bytesTransferred:this.stats.bytesTransferred,features:{instantHover:this.config.instantHover,instantTransitions:this.config.instantTransitions,connectionAware:this.config.connectionAware,crossTabCache:this.config.crossTabCache&&!!this.broadcastChannel,ssrHints:this.config.ssrHints,debug:this.config.debug,verboseLogging:this.config.verboseLogging},config:{initialDelay:this.config.initialDelay,betweenDelay:this.config.betweenDelay,hoverDelay:this.config.hoverDelay,maxConcurrent:this.config.maxConcurrent,effectiveMaxConcurrent:this.getEffectiveMaxConcurrent(),requestTimeout:this.config.requestTimeout}}}async clearCache(){try{if(this.cacheAPI){const e=await this.cacheAPI.keys();await Promise.all(e.map(e=>this.cacheAPI.delete(e)))}this.cache.clear(),this.processed.clear(),this.processing.clear(),this.queue=[],this.dataUsed=0,this.broadcastChannel&&this.broadcastChannel.postMessage({type:"cache-clear",timestamp:Date.now()}),this.debugLog("Cache cleared")}catch(e){this.debugLog("Cache clear error:",e)}}pause(){this.isPaused=!0,this.debugLog("Preloading paused")}resume(){this.isPaused=!1,this.processQueue(),this.debugLog("Preloading resumed")}destroy(){this.hoverTimeouts.forEach(e=>clearTimeout(e)),this.hoverTimeouts.clear(),this.broadcastChannel&&this.broadcastChannel.close(),this.clearCache(),this.connectionInfo&&this.connectionInfo.removeEventListener&&this.connectionInfo.removeEventListener("change",this.connectionChangeHandler),this.debugLog("Ghostloader destroyed")}}"undefined"!=typeof module&&module.exports?module.exports=e:"undefined"!=typeof window&&(window.Ghostloader=e);export{e as default};
//# sourceMappingURL=ghostloader.esm.js.map
