{"version":3,"file":"ghostloader.umd.js","sources":["../src/index.js"],"sourcesContent":["/**\r\n * Ghostloader - Lightweight Smart Preloading Engine\r\n * Version 0.2\r\n */\r\n\r\nclass Ghostloader {\r\n  constructor() {\r\n    this.config = {\r\n      cacheMode: 'local', // local or external\r\n      instantHover: true, // if true, the preloading will be boosted when the mouse is over the link\r\n      maxConcurrent: 3, // the maximum number of concurrent requests\r\n      selector: 'a[href]', // the selector to use to find the links to preload\r\n\r\n      // New delay configurations\r\n      initialDelay: 1000, // delay before starting preloading (ms)\r\n      betweenDelay: 100, // delay between processing queue items (ms)\r\n      hoverDelay: 150, // delay before boosting hovered links (ms)\r\n\r\n      // Exclusion patterns\r\n      excludeSelectors: [\r\n        '[download]',\r\n        '[target=\"_blank\"]',\r\n        '[href^=\"mailto:\"]',\r\n        '[href^=\"tel:\"]',\r\n        '[href^=\"#\"]',\r\n        '.no-preload'\r\n      ],\r\n      excludePatterns: [\r\n        /\\.(pdf|zip|doc|docx|xls|xlsx|ppt|pptx)$/i,\r\n        /\\.(jpg|jpeg|png|gif|svg|webp)$/i,\r\n        /^javascript:/,\r\n        /^data:/\r\n      ],\r\n\r\n      // Network and performance\r\n      fetchHeaders: {},\r\n      requestTimeout: 10000, // 10 seconds\r\n      connectionAware: true,\r\n      dataLimit: 50 * 1024 * 1024, // 50MB per session\r\n      bandwidthThrottle: true,\r\n\r\n      // Cache configuration\r\n      cacheMaxSize: 100, // maximum number of cached items\r\n      cacheExpiration: 24 * 60 * 60 * 1000, // 24 hours in ms\r\n      cacheVersion: '1.0',\r\n      crossTabCache: true,\r\n\r\n      // Debug and logging\r\n      debug: false,\r\n      verboseLogging: false,\r\n\r\n      // Advanced features\r\n      instantTransitions: true,\r\n      ssrHints: true\r\n    };\r\n\r\n    this.queue = [];\r\n    this.processing = new Set();\r\n    this.processed = new Set();\r\n    this.cache = new Map(); // Fallback cache\r\n    this.cacheAPI = null;\r\n    this.isInitialized = false;\r\n    this.activeRequests = 0;\r\n\r\n    // New state tracking\r\n    this.hoverTimeouts = new Map();\r\n    this.dataUsed = 0;\r\n    this.sessionStart = Date.now();\r\n    this.connectionInfo = null;\r\n    this.bandwidthEstimate = null;\r\n    this.ssrHintsReceived = new Set();\r\n\r\n    // Performance monitoring\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      bytesTransferred: 0,\r\n      averageResponseTime: 0,\r\n      connectionType: 'unknown'\r\n    };\r\n\r\n    // Cross-tab communication\r\n    this.broadcastChannel = null;\r\n  }\r\n\r\n  /**\r\n   * Initialize Ghostloader with custom options\r\n   * @param {Object} options - Configuration options\r\n   */\r\n  static init(options = {}) {\r\n    const instance = new Ghostloader();\r\n    instance.configure(options);\r\n    instance.start();\r\n    return instance;\r\n  }\r\n\r\n  /**\r\n   * Configure the instance with user options\r\n   * @param {Object} options - Configuration options\r\n   */\r\n  configure(options) {\r\n    this.config = { ...this.config, ...options };\r\n    this.log('Configured with options:', this.config);\r\n  }\r\n\r\n  /**\r\n   * Start the preloading process\r\n   */\r\n  async start() {\r\n    if (this.isInitialized) {\r\n      this.debugLog('Already initialized');\r\n      return;\r\n    }\r\n\r\n    this.debugLog('Starting Ghostloader...');\r\n\r\n    // Detect connection information\r\n    if (this.config.connectionAware) {\r\n      await this.detectConnection();\r\n    }\r\n\r\n    // Set up cross-tab communication\r\n    if (this.config.crossTabCache) {\r\n      this.setupCrossTabCache();\r\n    }\r\n\r\n    // Initialize cache system\r\n    await this.initializeCache();\r\n\r\n    // Process server-side rendering hints\r\n    if (this.config.ssrHints) {\r\n      this.processSSRHints();\r\n    }\r\n\r\n    // Apply initial delay before starting\r\n    if (this.config.initialDelay > 0) {\r\n      this.debugLog(`Waiting ${this.config.initialDelay}ms before starting preloading`);\r\n      await this.delay(this.config.initialDelay);\r\n    }\r\n\r\n    // Build initial queue from visible links\r\n    this.buildQueue();\r\n\r\n    // Set up instant hover listeners if enabled\r\n    if (this.config.instantHover) {\r\n      this.setupHoverListeners();\r\n    }\r\n\r\n    // Set up instant transitions if enabled\r\n    if (this.config.instantTransitions) {\r\n      this.setupInstantTransitions();\r\n    }\r\n\r\n    // Start processing queue\r\n    this.processQueue();\r\n\r\n    this.isInitialized = true;\r\n    this.debugLog('Ghostloader initialized successfully');\r\n  }\r\n\r\n  /**\r\n   * Initialize cache system (Cache API or fallback)\r\n   */\r\n  async initializeCache() {\r\n    try {\r\n      if ('caches' in window) {\r\n        this.cacheAPI = await caches.open('ghostloader-cache-v1');\r\n        this.log('Cache API initialized');\r\n      } else {\r\n        this.log('Cache API not available, using memory fallback');\r\n      }\r\n    } catch (error) {\r\n      this.log('Cache API initialization failed, using memory fallback:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build priority queue from visible links, sorted by DOM position\r\n   */\r\n  buildQueue() {\r\n    const links = document.querySelectorAll(this.config.selector);\r\n    const linkData = [];\r\n\r\n    links.forEach(link => {\r\n      const href = this.normalizeUrl(link.href);\r\n\r\n      // Skip if already processed or invalid\r\n      if (!href || this.processed.has(href) || this.processing.has(href)) {\r\n        return;\r\n      }\r\n\r\n      // Check exclusion patterns\r\n      if (this.shouldExclude(link, href)) {\r\n        this.verboseLog('Excluded link:', href);\r\n        return;\r\n      }\r\n\r\n      // Check cache mode restrictions\r\n      if (!this.shouldPreload(href)) {\r\n        return;\r\n      }\r\n\r\n      // Check data usage limits\r\n      if (this.config.connectionAware && !this.withinDataLimits()) {\r\n        this.debugLog('Data limit reached, skipping preloading');\r\n        return;\r\n      }\r\n\r\n      // Get element position for priority sorting\r\n      const rect = link.getBoundingClientRect();\r\n      const isVisible = rect.top < window.innerHeight && rect.bottom > 0;\r\n\r\n      if (isVisible) {\r\n        linkData.push({\r\n          url: href,\r\n          element: link,\r\n          priority: rect.top, // Top-to-bottom priority\r\n          timestamp: Date.now()\r\n        });\r\n      }\r\n    });\r\n\r\n    // Sort by priority (top to bottom)\r\n    linkData.sort((a, b) => a.priority - b.priority);\r\n\r\n    this.queue = linkData;\r\n    this.debugLog(`Built queue with ${this.queue.length} links`);\r\n  }\r\n\r\n  /**\r\n   * Check if URL should be preloaded based on cache mode\r\n   * @param {string} url - URL to check\r\n   * @returns {boolean}\r\n   */\r\n  shouldPreload(url) {\r\n    try {\r\n      const urlObj = new URL(url);\r\n      const currentOrigin = window.location.origin;\r\n\r\n      if (this.config.cacheMode === 'local') {\r\n        return urlObj.origin === currentOrigin;\r\n      }\r\n\r\n      // For external mode, allow all URLs (CORS will be handled during fetch)\r\n      return true;\r\n    } catch (error) {\r\n      this.log('Invalid URL:', url, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize URL for consistent caching\r\n   * @param {string} url - URL to normalize\r\n   * @returns {string|null}\r\n   */\r\n  normalizeUrl(url) {\r\n    try {\r\n      const urlObj = new URL(url, window.location.href);\r\n      // Remove hash for caching purposes\r\n      urlObj.hash = '';\r\n      return urlObj.href;\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up hover listeners for instant priority boost\r\n   */\r\n  setupHoverListeners() {\r\n    document.addEventListener('mouseenter', (event) => {\r\n      if (event.target.matches(this.config.selector)) {\r\n        const href = this.normalizeUrl(event.target.href);\r\n        if (href && this.shouldPreload(href) && !this.shouldExclude(event.target, href)) {\r\n          // Clear any existing timeout for this element\r\n          if (this.hoverTimeouts.has(event.target)) {\r\n            clearTimeout(this.hoverTimeouts.get(event.target));\r\n          }\r\n\r\n          // Set hover delay threshold\r\n          const timeoutId = setTimeout(() => {\r\n            this.boostPriority(href);\r\n            this.hoverTimeouts.delete(event.target);\r\n          }, this.config.hoverDelay);\r\n\r\n          this.hoverTimeouts.set(event.target, timeoutId);\r\n        }\r\n      }\r\n    }, true);\r\n\r\n    // Clean up hover timeouts on mouse leave\r\n    document.addEventListener('mouseleave', (event) => {\r\n      if (event.target.matches(this.config.selector)) {\r\n        if (this.hoverTimeouts.has(event.target)) {\r\n          clearTimeout(this.hoverTimeouts.get(event.target));\r\n          this.hoverTimeouts.delete(event.target);\r\n        }\r\n      }\r\n    }, true);\r\n\r\n    this.debugLog('Hover listeners enabled with', this.config.hoverDelay, 'ms delay');\r\n  }\r\n\r\n  /**\r\n   * Move hovered link to front of queue\r\n   * @param {string} url - URL to boost\r\n   */\r\n  boostPriority(url) {\r\n    // Find link in queue\r\n    const index = this.queue.findIndex(item => item.url === url);\r\n\r\n    if (index > 0) {\r\n      // Move to front\r\n      const item = this.queue.splice(index, 1)[0];\r\n      this.queue.unshift(item);\r\n      this.log('Boosted priority for:', url);\r\n\r\n      // Trigger immediate processing if not at max concurrency\r\n      this.processQueue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process the queue with concurrency control\r\n   */\r\n  async processQueue() {\r\n    while (this.queue.length > 0 && this.activeRequests < this.getEffectiveMaxConcurrent()) {\r\n      const item = this.queue.shift();\r\n\r\n      if (!item || this.processing.has(item.url) || this.processed.has(item.url)) {\r\n        continue;\r\n      }\r\n\r\n      // Check data limits before processing\r\n      if (this.config.connectionAware && !this.withinDataLimits()) {\r\n        this.debugLog('Data limit reached, pausing queue processing');\r\n        break;\r\n      }\r\n\r\n      this.processing.add(item.url);\r\n      this.activeRequests++;\r\n\r\n      // Apply between-delay if configured\r\n      if (this.config.betweenDelay > 0 && this.activeRequests > 1) {\r\n        await this.delay(this.config.betweenDelay);\r\n      }\r\n\r\n      // Process item asynchronously\r\n      this.fetchAndCache(item).finally(() => {\r\n        this.processing.delete(item.url);\r\n        this.processed.add(item.url);\r\n        this.activeRequests--;\r\n\r\n        // Continue processing queue\r\n        if (this.queue.length > 0) {\r\n          // Small delay before continuing to prevent overwhelming\r\n          setTimeout(() => this.processQueue(), 10);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch and cache a page\r\n   * @param {Object} item - Queue item with url and metadata\r\n   */\r\n  async fetchAndCache(item) {\r\n    const { url } = item;\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      this.verboseLog('Fetching:', url);\r\n      this.stats.totalRequests++;\r\n\r\n      // Check if already cached and not expired\r\n      const cachedResponse = await this.getCachedResponse(url);\r\n      if (cachedResponse && !this.isCacheExpired(cachedResponse)) {\r\n        this.debugLog('Cache hit:', url);\r\n        this.stats.cacheHits++;\r\n        return;\r\n      }\r\n\r\n      // Prepare fetch options with custom headers and timeout\r\n      const fetchOptions = {\r\n        method: 'GET',\r\n        mode: this.config.cacheMode === 'external' ? 'cors' : 'same-origin',\r\n        credentials: 'same-origin',\r\n        cache: 'default',\r\n        headers: {\r\n          ...this.config.fetchHeaders,\r\n          'X-Ghostloader': 'preload',\r\n          'X-Ghostloader-Version': this.config.cacheVersion\r\n        }\r\n      };\r\n\r\n      // Create timeout controller\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), this.config.requestTimeout);\r\n      fetchOptions.signal = controller.signal;\r\n\r\n      const response = await fetch(url, fetchOptions);\r\n      clearTimeout(timeoutId);\r\n\r\n      if (response.ok) {\r\n        // Track data usage\r\n        const contentLength = response.headers.get('content-length');\r\n        if (contentLength) {\r\n          this.dataUsed += parseInt(contentLength, 10);\r\n        }\r\n\r\n        // Store in cache with versioning\r\n        await this.storeInCache(url, response.clone(), {\r\n          timestamp: Date.now(),\r\n          version: this.config.cacheVersion,\r\n          size: contentLength ? parseInt(contentLength, 10) : 0\r\n        });\r\n\r\n        this.debugLog('Cached:', url);\r\n        this.stats.cacheMisses++;\r\n        this.stats.bytesTransferred += contentLength ? parseInt(contentLength, 10) : 0;\r\n\r\n        // Broadcast to other tabs\r\n        this.broadcastCacheUpdate(url, 'cached');\r\n\r\n      } else {\r\n        this.debugLog('Fetch failed:', url, response.status);\r\n      }\r\n\r\n      // Update performance stats\r\n      const responseTime = Date.now() - startTime;\r\n      this.stats.averageResponseTime =\r\n        (this.stats.averageResponseTime * (this.stats.totalRequests - 1) + responseTime) / this.stats.totalRequests;\r\n\r\n    } catch (error) {\r\n      if (error.name === 'AbortError') {\r\n        this.debugLog('Request timeout:', url);\r\n      } else {\r\n        this.debugLog('Fetch error:', url, error.message);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if URL is in cache\r\n   * @param {string} url - URL to check\r\n   * @returns {boolean}\r\n   */\r\n  async isInCache(url) {\r\n    try {\r\n      if (this.cacheAPI) {\r\n        const response = await this.cacheAPI.match(url);\r\n        return !!response;\r\n      } else {\r\n        return this.cache.has(url);\r\n      }\r\n    } catch (error) {\r\n      this.log('Cache check error:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Store response in cache\r\n   * @param {string} url - URL to cache\r\n   * @param {Response} response - Response to store\r\n   */\r\n  async storeInCache(url, response) {\r\n    try {\r\n      if (this.cacheAPI) {\r\n        await this.cacheAPI.put(url, response);\r\n      } else {\r\n        // Store minimal data in memory fallback\r\n        this.cache.set(url, {\r\n          url,\r\n          timestamp: Date.now(),\r\n          status: response.status\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.log('Cache store error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if URL should be excluded based on patterns\r\n   * @param {HTMLElement} element - Link element\r\n   * @param {string} url - URL to check\r\n   * @returns {boolean}\r\n   */\r\n  shouldExclude(element, url) {\r\n    // Check selector exclusions\r\n    for (const selector of this.config.excludeSelectors) {\r\n      if (element.matches(selector)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check pattern exclusions\r\n    for (const pattern of this.config.excludePatterns) {\r\n      if (pattern.test(url)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Detect connection information\r\n   */\r\n  async detectConnection() {\r\n    try {\r\n      if ('connection' in navigator) {\r\n        this.connectionInfo = navigator.connection;\r\n        this.stats.connectionType = this.connectionInfo.effectiveType || 'unknown';\r\n\r\n        // Estimate bandwidth\r\n        if (this.connectionInfo.downlink) {\r\n          this.bandwidthEstimate = this.connectionInfo.downlink * 1000 * 1000; // Convert to bytes/s\r\n        }\r\n\r\n        this.debugLog('Connection detected:', {\r\n          type: this.connectionInfo.effectiveType,\r\n          downlink: this.connectionInfo.downlink,\r\n          saveData: this.connectionInfo.saveData\r\n        });\r\n\r\n        // Listen for connection changes\r\n        this.connectionInfo.addEventListener('change', () => {\r\n          this.debugLog('Connection changed:', this.connectionInfo.effectiveType);\r\n          this.stats.connectionType = this.connectionInfo.effectiveType;\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.debugLog('Connection detection failed:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if within data usage limits\r\n   * @returns {boolean}\r\n   */\r\n  withinDataLimits() {\r\n    // Respect data saver mode\r\n    if (this.connectionInfo && this.connectionInfo.saveData) {\r\n      this.debugLog('Data saver mode enabled, skipping preload');\r\n      return false;\r\n    }\r\n\r\n    // Check session data limit\r\n    if (this.dataUsed >= this.config.dataLimit) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get effective max concurrent requests based on connection\r\n   * @returns {number}\r\n   */\r\n  getEffectiveMaxConcurrent() {\r\n    if (!this.config.bandwidthThrottle || !this.connectionInfo) {\r\n      return this.config.maxConcurrent;\r\n    }\r\n\r\n    // Throttle based on connection type\r\n    const connectionLimits = {\r\n      'slow-2g': 1,\r\n      '2g': 1,\r\n      '3g': 2,\r\n      '4g': this.config.maxConcurrent,\r\n      '5g': this.config.maxConcurrent\r\n    };\r\n\r\n    return connectionLimits[this.connectionInfo.effectiveType] || this.config.maxConcurrent;\r\n  }\r\n\r\n  /**\r\n   * Set up cross-tab cache communication\r\n   */\r\n  setupCrossTabCache() {\r\n    try {\r\n      if ('BroadcastChannel' in window) {\r\n        this.broadcastChannel = new BroadcastChannel('ghostloader-cache');\r\n\r\n        this.broadcastChannel.addEventListener('message', (event) => {\r\n          const { type, url, data } = event.data;\r\n\r\n          if (type === 'cache-update') {\r\n            this.verboseLog('Received cache update from another tab:', url);\r\n            // Mark as processed to avoid duplicate fetching\r\n            this.processed.add(url);\r\n          } else if (type === 'cache-invalidate') {\r\n            this.verboseLog('Received cache invalidation from another tab:', url);\r\n            this.invalidateCache(url);\r\n          }\r\n        });\r\n\r\n        this.debugLog('Cross-tab cache communication enabled');\r\n      }\r\n    } catch (error) {\r\n      this.debugLog('Cross-tab cache setup failed:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcast cache update to other tabs\r\n   * @param {string} url - URL that was cached\r\n   * @param {string} action - Action type\r\n   */\r\n  broadcastCacheUpdate(url, action) {\r\n    if (this.broadcastChannel) {\r\n      this.broadcastChannel.postMessage({\r\n        type: 'cache-update',\r\n        url,\r\n        action,\r\n        timestamp: Date.now()\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process server-side rendering hints\r\n   */\r\n  processSSRHints() {\r\n    try {\r\n      // Look for SSR hints in meta tags\r\n      const ssrHints = document.querySelectorAll('meta[name=\"ghostloader-hint\"]');\r\n      ssrHints.forEach(meta => {\r\n        const url = meta.getAttribute('content');\r\n        const priority = meta.getAttribute('data-priority') || 'normal';\r\n\r\n        if (url && !this.ssrHintsReceived.has(url)) {\r\n          this.ssrHintsReceived.add(url);\r\n\r\n          // Add to queue with high priority if specified\r\n          if (priority === 'high') {\r\n            this.queue.unshift({\r\n              url: this.normalizeUrl(url),\r\n              element: null,\r\n              priority: -1000, // Very high priority\r\n              timestamp: Date.now(),\r\n              source: 'ssr-hint'\r\n            });\r\n          }\r\n\r\n          this.verboseLog('Processed SSR hint:', url, 'priority:', priority);\r\n        }\r\n      });\r\n\r\n      // Look for hints in JSON-LD scripts\r\n      const jsonLdScripts = document.querySelectorAll('script[type=\"application/ld+json\"]');\r\n      jsonLdScripts.forEach(script => {\r\n        try {\r\n          const data = JSON.parse(script.textContent);\r\n          if (data.ghostloaderHints && Array.isArray(data.ghostloaderHints)) {\r\n            data.ghostloaderHints.forEach(hint => {\r\n              if (hint.url && !this.ssrHintsReceived.has(hint.url)) {\r\n                this.ssrHintsReceived.add(hint.url);\r\n                this.queue.unshift({\r\n                  url: this.normalizeUrl(hint.url),\r\n                  element: null,\r\n                  priority: hint.priority || 0,\r\n                  timestamp: Date.now(),\r\n                  source: 'ssr-hint-json'\r\n                });\r\n              }\r\n            });\r\n          }\r\n        } catch (e) {\r\n          // Ignore invalid JSON-LD\r\n        }\r\n      });\r\n\r\n    } catch (error) {\r\n      this.debugLog('SSR hints processing failed:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up instant page transitions\r\n   */\r\n  setupInstantTransitions() {\r\n    document.addEventListener('click', async (event) => {\r\n      if (event.target.matches(this.config.selector) && !event.defaultPrevented) {\r\n        const href = this.normalizeUrl(event.target.href);\r\n\r\n        if (href && await this.isInCache(href) && !this.shouldExclude(event.target, href)) {\r\n          const cachedResponse = await this.getCachedResponse(href);\r\n\r\n          if (cachedResponse && !this.isCacheExpired(cachedResponse)) {\r\n            // Prevent default navigation\r\n            event.preventDefault();\r\n\r\n            try {\r\n              // Get cached content\r\n              const html = await cachedResponse.text();\r\n\r\n              // Create new document\r\n              const parser = new DOMParser();\r\n              const newDoc = parser.parseFromString(html, 'text/html');\r\n\r\n              // Replace current page content\r\n              document.title = newDoc.title;\r\n              document.head.innerHTML = newDoc.head.innerHTML;\r\n              document.body.innerHTML = newDoc.body.innerHTML;\r\n\r\n              // Update URL\r\n              history.pushState(null, newDoc.title, href);\r\n\r\n              // Reinitialize Ghostloader for new page\r\n              setTimeout(() => {\r\n                this.buildQueue();\r\n                this.processQueue();\r\n              }, 100);\r\n\r\n              this.debugLog('Instant transition to:', href);\r\n\r\n            } catch (error) {\r\n              this.debugLog('Instant transition failed:', error);\r\n              // Fallback to normal navigation\r\n              window.location.href = href;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    this.debugLog('Instant transitions enabled');\r\n  }\r\n\r\n  /**\r\n   * Get cached response with metadata\r\n   * @param {string} url - URL to check\r\n   * @returns {Response|null}\r\n   */\r\n  async getCachedResponse(url) {\r\n    try {\r\n      if (this.cacheAPI) {\r\n        return await this.cacheAPI.match(url);\r\n      } else if (this.cache.has(url)) {\r\n        const cached = this.cache.get(url);\r\n        // Return a mock response for memory cache\r\n        return {\r\n          ok: true,\r\n          status: 200,\r\n          text: () => Promise.resolve(cached.content || ''),\r\n          clone: () => this.getCachedResponse(url),\r\n          headers: new Map([['x-cached-timestamp', cached.timestamp.toString()]])\r\n        };\r\n      }\r\n    } catch (error) {\r\n      this.debugLog('Cache retrieval error:', error);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if cache entry is expired\r\n   * @param {Response} response - Cached response\r\n   * @returns {boolean}\r\n   */\r\n  isCacheExpired(response) {\r\n    try {\r\n      const timestamp = response.headers.get('x-cached-timestamp') ||\r\n        response.headers.get('x-ghostloader-timestamp');\r\n\r\n      if (timestamp) {\r\n        const age = Date.now() - parseInt(timestamp, 10);\r\n        return age > this.config.cacheExpiration;\r\n      }\r\n    } catch (error) {\r\n      this.debugLog('Cache expiration check error:', error);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Store response in cache with metadata\r\n   * @param {string} url - URL to cache\r\n   * @param {Response} response - Response to store\r\n   * @param {Object} metadata - Additional metadata\r\n   */\r\n  async storeInCache(url, response, metadata = {}) {\r\n    try {\r\n      // Enforce cache size limits\r\n      await this.enforceCacheLimit();\r\n\r\n      if (this.cacheAPI) {\r\n        // Add custom headers for metadata\r\n        const modifiedResponse = new Response(response.body, {\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          headers: {\r\n            ...Object.fromEntries(response.headers.entries()),\r\n            'x-ghostloader-timestamp': metadata.timestamp || Date.now(),\r\n            'x-ghostloader-version': metadata.version || this.config.cacheVersion,\r\n            'x-ghostloader-size': metadata.size || 0\r\n          }\r\n        });\r\n\r\n        await this.cacheAPI.put(url, modifiedResponse);\r\n      } else {\r\n        // Store in memory cache\r\n        const content = await response.text();\r\n        this.cache.set(url, {\r\n          url,\r\n          content,\r\n          timestamp: metadata.timestamp || Date.now(),\r\n          version: metadata.version || this.config.cacheVersion,\r\n          size: metadata.size || content.length\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.debugLog('Cache store error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce cache size limits\r\n   */\r\n  async enforceCacheLimit() {\r\n    try {\r\n      if (this.cacheAPI) {\r\n        const keys = await this.cacheAPI.keys();\r\n        if (keys.length >= this.config.cacheMaxSize) {\r\n          // Remove oldest entries (simple FIFO for now)\r\n          const toRemove = keys.slice(0, keys.length - this.config.cacheMaxSize + 10);\r\n          await Promise.all(toRemove.map(request => this.cacheAPI.delete(request)));\r\n          this.debugLog('Cleaned cache, removed', toRemove.length, 'entries');\r\n        }\r\n      } else {\r\n        if (this.cache.size >= this.config.cacheMaxSize) {\r\n          // Remove oldest entries from memory cache\r\n          const entries = Array.from(this.cache.entries())\r\n            .sort((a, b) => a[1].timestamp - b[1].timestamp);\r\n\r\n          const toRemove = entries.slice(0, entries.length - this.config.cacheMaxSize + 10);\r\n          toRemove.forEach(([key]) => this.cache.delete(key));\r\n          this.debugLog('Cleaned memory cache, removed', toRemove.length, 'entries');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.debugLog('Cache cleanup error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidate cache entry\r\n   * @param {string} url - URL to invalidate\r\n   */\r\n  async invalidateCache(url) {\r\n    try {\r\n      if (this.cacheAPI) {\r\n        await this.cacheAPI.delete(url);\r\n      } else {\r\n        this.cache.delete(url);\r\n      }\r\n      this.debugLog('Invalidated cache for:', url);\r\n    } catch (error) {\r\n      this.debugLog('Cache invalidation error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility delay function\r\n   * @param {number} ms - Milliseconds to delay\r\n   * @returns {Promise}\r\n   */\r\n  delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  /**\r\n   * Debug logging utility\r\n   * @param {...any} args - Arguments to log\r\n   */\r\n  debugLog(...args) {\r\n    if (this.config.debug && typeof console !== 'undefined') {\r\n      console.log('[Ghostloader Debug]', ...args);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verbose logging utility\r\n   * @param {...any} args - Arguments to log\r\n   */\r\n  verboseLog(...args) {\r\n    if (this.config.verboseLogging && typeof console !== 'undefined') {\r\n      console.log('[Ghostloader Verbose]', ...args);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple logging utility (kept for backward compatibility)\r\n   * @param {...any} args - Arguments to log\r\n   */\r\n  log(...args) {\r\n    this.debugLog(...args);\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive cache and performance statistics\r\n   * @returns {Object} Enhanced stats\r\n   */\r\n  getStats() {\r\n    const cacheSize = this.cacheAPI ? 'Cache API' : this.cache.size;\r\n    const sessionDuration = Date.now() - this.sessionStart;\r\n\r\n    return {\r\n      // Queue information\r\n      queueLength: this.queue.length,\r\n      processing: this.processing.size,\r\n      processed: this.processed.size,\r\n      activeRequests: this.activeRequests,\r\n\r\n      // Cache information\r\n      cacheSize,\r\n      cacheMaxSize: this.config.cacheMaxSize,\r\n      cacheExpiration: this.config.cacheExpiration,\r\n      cacheVersion: this.config.cacheVersion,\r\n\r\n      // Performance metrics\r\n      totalRequests: this.stats.totalRequests,\r\n      cacheHits: this.stats.cacheHits,\r\n      cacheMisses: this.stats.cacheMisses,\r\n      cacheHitRate: this.stats.totalRequests > 0 ?\r\n        (this.stats.cacheHits / this.stats.totalRequests * 100).toFixed(2) + '%' : '0%',\r\n\r\n      // Network information\r\n      connectionType: this.stats.connectionType,\r\n      bandwidthEstimate: this.bandwidthEstimate,\r\n      dataUsed: this.dataUsed,\r\n      dataLimit: this.config.dataLimit,\r\n      dataUsagePercent: ((this.dataUsed / this.config.dataLimit) * 100).toFixed(2) + '%',\r\n\r\n      // Timing information\r\n      sessionDuration,\r\n      averageResponseTime: this.stats.averageResponseTime.toFixed(2) + 'ms',\r\n      bytesTransferred: this.stats.bytesTransferred,\r\n\r\n      // Feature status\r\n      features: {\r\n        instantHover: this.config.instantHover,\r\n        instantTransitions: this.config.instantTransitions,\r\n        connectionAware: this.config.connectionAware,\r\n        crossTabCache: this.config.crossTabCache && !!this.broadcastChannel,\r\n        ssrHints: this.config.ssrHints,\r\n        debug: this.config.debug,\r\n        verboseLogging: this.config.verboseLogging\r\n      },\r\n\r\n      // Configuration\r\n      config: {\r\n        initialDelay: this.config.initialDelay,\r\n        betweenDelay: this.config.betweenDelay,\r\n        hoverDelay: this.config.hoverDelay,\r\n        maxConcurrent: this.config.maxConcurrent,\r\n        effectiveMaxConcurrent: this.getEffectiveMaxConcurrent(),\r\n        requestTimeout: this.config.requestTimeout\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all caches and reset state\r\n   */\r\n  async clearCache() {\r\n    try {\r\n      if (this.cacheAPI) {\r\n        const keys = await this.cacheAPI.keys();\r\n        await Promise.all(keys.map(request => this.cacheAPI.delete(request)));\r\n      }\r\n\r\n      this.cache.clear();\r\n      this.processed.clear();\r\n      this.processing.clear();\r\n      this.queue = [];\r\n      this.dataUsed = 0;\r\n\r\n      // Broadcast cache clear to other tabs\r\n      if (this.broadcastChannel) {\r\n        this.broadcastChannel.postMessage({\r\n          type: 'cache-clear',\r\n          timestamp: Date.now()\r\n        });\r\n      }\r\n\r\n      this.debugLog('Cache cleared');\r\n    } catch (error) {\r\n      this.debugLog('Cache clear error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pause preloading\r\n   */\r\n  pause() {\r\n    this.isPaused = true;\r\n    this.debugLog('Preloading paused');\r\n  }\r\n\r\n  /**\r\n   * Resume preloading\r\n   */\r\n  resume() {\r\n    this.isPaused = false;\r\n    this.processQueue();\r\n    this.debugLog('Preloading resumed');\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources and event listeners\r\n   */\r\n  destroy() {\r\n    // Clear all timeouts\r\n    this.hoverTimeouts.forEach(timeoutId => clearTimeout(timeoutId));\r\n    this.hoverTimeouts.clear();\r\n\r\n    // Close broadcast channel\r\n    if (this.broadcastChannel) {\r\n      this.broadcastChannel.close();\r\n    }\r\n\r\n    // Clear caches\r\n    this.clearCache();\r\n\r\n    // Remove connection listener\r\n    if (this.connectionInfo && this.connectionInfo.removeEventListener) {\r\n      this.connectionInfo.removeEventListener('change', this.connectionChangeHandler);\r\n    }\r\n\r\n    this.debugLog('Ghostloader destroyed');\r\n  }\r\n}\r\n\r\n// Export for ES modules and global usage\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = Ghostloader;\r\n} else if (typeof window !== 'undefined') {\r\n  window.Ghostloader = Ghostloader;\r\n}\r\n\r\nexport default Ghostloader;\r\n"],"names":["Ghostloader","constructor","this","config","cacheMode","instantHover","maxConcurrent","selector","initialDelay","betweenDelay","hoverDelay","excludeSelectors","excludePatterns","fetchHeaders","requestTimeout","connectionAware","dataLimit","bandwidthThrottle","cacheMaxSize","cacheExpiration","cacheVersion","crossTabCache","debug","verboseLogging","instantTransitions","ssrHints","queue","processing","Set","processed","cache","Map","cacheAPI","isInitialized","activeRequests","hoverTimeouts","dataUsed","sessionStart","Date","now","connectionInfo","bandwidthEstimate","ssrHintsReceived","stats","totalRequests","cacheHits","cacheMisses","bytesTransferred","averageResponseTime","connectionType","broadcastChannel","init","options","instance","configure","start","log","debugLog","detectConnection","setupCrossTabCache","initializeCache","processSSRHints","delay","buildQueue","setupHoverListeners","setupInstantTransitions","processQueue","window","caches","open","error","links","document","querySelectorAll","linkData","forEach","link","href","normalizeUrl","has","shouldExclude","verboseLog","shouldPreload","withinDataLimits","rect","getBoundingClientRect","top","innerHeight","bottom","push","url","element","priority","timestamp","sort","a","b","length","urlObj","URL","currentOrigin","location","origin","hash","addEventListener","event","target","matches","clearTimeout","get","timeoutId","setTimeout","boostPriority","delete","set","index","findIndex","item","splice","unshift","getEffectiveMaxConcurrent","shift","add","fetchAndCache","finally","startTime","cachedResponse","getCachedResponse","isCacheExpired","fetchOptions","method","mode","credentials","headers","controller","AbortController","abort","signal","response","fetch","ok","contentLength","parseInt","storeInCache","clone","version","size","broadcastCacheUpdate","status","responseTime","name","message","isInCache","match","put","pattern","test","navigator","connection","effectiveType","downlink","type","saveData","BroadcastChannel","data","invalidateCache","action","postMessage","meta","getAttribute","source","script","JSON","parse","textContent","ghostloaderHints","Array","isArray","hint","e","async","defaultPrevented","preventDefault","html","text","newDoc","DOMParser","parseFromString","title","head","innerHTML","body","history","pushState","cached","Promise","resolve","content","toString","metadata","enforceCacheLimit","modifiedResponse","Response","statusText","Object","fromEntries","entries","keys","toRemove","slice","all","map","request","from","key","ms","args","console","getStats","cacheSize","sessionDuration","queueLength","cacheHitRate","toFixed","dataUsagePercent","features","effectiveMaxConcurrent","clearCache","clear","pause","isPaused","resume","destroy","close","removeEventListener","connectionChangeHandler","module","exports"],"mappings":"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"}